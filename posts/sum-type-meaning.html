<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title></title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/css/tachyons.min.css">
  <link rel="stylesheet" href="/css/site.css">
  <link rel="stylesheet" href="/css/post.css">
</head>
<body>
<div class="content">
<!-- THIS DOCUMENT IS AUTO GENERATED. DO NOT EDIT. -->
<!-- THIS DOCUMENT IS AUTO GENERATED. DO NOT EDIT. -->
<!-- THIS DOCUMENT IS AUTO GENERATED. DO NOT EDIT. -->

<h1>Same (sum) type, different meaning</h1>

<p>Recently I wrote a small, Scheme like language for a presentation I gave at a
local conference. The point of the presentation was to talk about the
implementation as a whole, so the code had to be concise. As a result, I ended
up stumbling across a pattern in Scala that allowed me to share types all
through out the lexing to the evaluation stages of the interpreter. Doing so
meant that I didn&rsquo;t have to translate an AST into a runtime representation of
the program and its state, and instead was able to continue using the same tree
throughout the execution.</p>

<p>Let me start by giving an example of the pattern I&rsquo;m used to running into and
using myself. Let&rsquo;s say we have a grammar like this one:</p>

<pre><code class="language-ebnf">arith = num op num ;
op    = '+' | '-' ;
num   = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
</code></pre>

<p>It&rsquo;s a simple grammar but it&rsquo;s one that demostrates both the problem and the
proposed solution. Finding yourself in a situation where you have to model this
as tokens and/or an AST, you may opt for a solution like the following:</p>

<pre><code class="language-scala">class Token(lexeme: String)
case class Operator(lexeme: String) extends Token(lexeme)
case class Number(lexeme: String) extends Token(lexeme)

class Expression
case class Arithmetic(lhs: Number, op: Operator, rhs: Number)
  extends Expression
</code></pre>

<p>At this point we&rsquo;re left with data structures that are more than good enough to
use as output of a parse and even an evaluator, the start running into problems
as soon as we want to start evaluating number, or allow arbitrarily nested
expressions.</p>

<p>Imagine the definition the <code>evaluate</code> function, which takes something and
returns a result. The signature looks something like this, <code>evaluate ⇒ a' ⇒
Number</code>. And what is <code>a'</code>? Well, it will most often be something of the type
<code>Arithmetic</code>, but it could also be a <code>Number</code>.</p>

<p>We can&rsquo;t accept an <code>Arithmetic | Number</code> type, since it&rsquo;s not allowed. We could
turn <code>Number</code> into an <code>Expression</code> instead and accept all <code>Expression</code> types.</p>

</div>

<footer class="bt ph3 ph3-m ph5-ns mt1 mt4-ns b--light-gray spectral pv1">
  <div class="container">
    <p class="lh-copy w-50-ns">
    ~ <a href="/" class="link red dim">Marcos Minond</a>
    </p>
  </div>
</footer>

</body>
</html>
