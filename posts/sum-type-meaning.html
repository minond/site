<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title></title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/css/tachyons.min.css">
  <link rel="stylesheet" href="/css/site.css">
  <style>
    @import url('https://fonts.googleapis.com/css?family=Spectral|IBM+Plex+Mono');

    body {
      cursor: default;
      font-size: 1.2rem;
    }

    .content {
      max-width: 42rem;
      padding: 1rem;
      transition: padding .25s;
      font-family: 'Spectral', serif;
    }

    h1 {
      line-height: 1.2;
      font-family: baskerville, serif;
      font-weight: 500;
      font-size: 2rem;
    }

    .content > h1:first-child,
    .content > h2:first-child,
    .content > h3:first-child,
    .content > h4:first-child {
      margin-top: 0;
    }

    pre {
      background-color: rgba(0, 0, 0, .02);
      margin: 2rem -1rem;
      padding: .5rem 1rem;
      font-size: 1rem;
      border-top: 1px solid #b7b7b7;
      border-bottom: 1px solid #b7b7b7;
    }

    pre > code {
      display: block;
      overflow: auto;
      line-height: 1.5;
    }

    code {
      font-family: 'IBM Plex Mono', monospace;
    }

    p {
      line-height: 1.5;
    }

    a {
      color: #357edd;
    }

    /* small */
    @media screen and (max-width: 45em) {
    }

    /* not small */
    @media screen and (min-width: 45em) {
      h1 {
        font-size: 2.75rem;
      }
    }

    /* medium */
    @media screen and (min-width: 45em) and (max-width: 60em) {
    }

    /* large */
    @media screen and (min-width: 60em) {
      .content {
        padding: 4rem;
      }
    }
  </style>
</head>
<body>
<div class="content">
<!-- THIS DOCUMENT IS AUTO GENERATED. DO NOT EDIT. -->
<!-- THIS DOCUMENT IS AUTO GENERATED. DO NOT EDIT. -->
<!-- THIS DOCUMENT IS AUTO GENERATED. DO NOT EDIT. -->

<h1>Same (sum) type, different meaning</h1>

<p>Recently I wrote a small, Scheme like language for a presentation I gave at a
local conference. The point of the presentation was to talk about the
implementation as a whole, so the code had to be concise. As a result, I ended
up stumbling across a pattern in Scala that allowed me to share types all
through out the lexing to the evaluation stages of the interpreter. Doing so
meant that I didn&rsquo;t have to translate an AST into a runtime representation of
the program and its state, and instead was able to continue using the same tree
throughout the execution.</p>

<p>Let me start by giving an example of the pattern I&rsquo;m used to running into and
using myself. Let&rsquo;s say we have a grammar like this one:</p>

<pre><code class="language-ebnf">arith = num '+' | '-' num ;
op    = '+' | '-' ;
num   = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
</code></pre>

<p>It&rsquo;s a simple grammar but it&rsquo;s one that demostrates both the problem and the
proposed solution. Finding yourself in a situation where you have to model this
as tokens and/or an AST, you may opt for a solution like the following:</p>

<pre><code class="language-scala">class Token(lexeme: String)
case class Operator(lexeme: String) extends Token(lexeme)
case class Number(lexeme: String) extends Token(lexeme)

class Expression
case class Arithmetic(lhs: Number, op: Operator, rhs: Number)
  extends Expression
</code></pre>

<p>At this point</p>

</div>

<footer class="bt ph3 ph4-ns mt1 mt4-ns b--light-gray spectral pv1">
  <div class="container">
    <p class="lh-copy w-50-ns">
    ~ <a href="/" class="link red dim">Marcos Minond</a>
    </p>
  </div>
</footer>

</body>
</html>
